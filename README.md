
## Path Planning Solution Documentation

### 1. Algorithm Overview

This path planning algorithm generates a smooth, drivable path based on the core idea of **dynamic boundary generation**. The fundamental concept is to treat the blue and yellow cones as points defining two "polygons" or boundaries—a left (blue) boundary and a right (yellow) boundary.

The algorithm's design aims to generate a path that always stays between these two boundaries. It dynamically switches between two key strategies to achieve this:

1.  **Centerline Generation (Two-Sided Path):** Used when *both* blue and yellow boundaries (polygons) are detected. It calculates a centerline by pairing points from each boundary and intelligently extrapolating a path.
2.  **Stable Offset Generation (One-Sided Path):** Used when *only one* boundary (e.g., just the blue polygon) is detected. It calculates a single, stable offset path that runs parallel to this boundary.

---

### 2. Core Strategies Explained

#### Strategy 1: Centerline Generation (Blue and Yellow Boundaries)

This strategy implements the "two-polygon" concept and is built on the idea of **Travel-Order Pairing and Extrapolation**. This approach was specifically designed to solve failures in complex curves (like Scenario 15).

* **Step 1: Travel-Order Sorting**
    Instead of sorting by proximity to the car (which caused errors), both the blue and yellow cone lists are independently sorted by their **`x`-coordinate** (`key=lambda c: c.x`). This establishes a correct **travel order**, assuming the track moves from left-to-right.

* **Step 2: Real Pair Midpoint Generation**
    The algorithm iterates through the `x`-sorted lists and creates "real pairs" for as long as both boundaries have points. The midpoint of each pair—e.g., `(blue[0], yellow[0])`—is calculated and added as a waypoint.

* **Step 3: Boundary Extrapolation (The "Virtual Cone" Concept)**
    This is the core innovation for handling uneven boundaries (like **Scenario 7**). The algorithm stores the vector from the *last real pair* (e.g., `y_cone.pos - b_cone.pos`). This `last_offset_vector` is stored as the "assumed track width and orientation," based purely on the detected boundary geometry.

* **Step 4: Virtual Waypoint Generation**
    For any remaining *unpaired* points on a boundary (e.g., an extra blue cone), the algorithm projects a "virtual" partner based on the stored track geometry. The midpoint between the real point and its virtual partner is then added to the waypoint list.

* **Step 5: Final Path Ordering**
    As a final, critical step, the *entire* list of waypoints (both real and virtual) is **sorted again by its `x`-coordinate** (`waypoints.sort(key=lambda p: p[0])`). This guarantees the final path is non-looping and strictly adheres to the left-to-right travel order, **correctly solving the backward-turn failure seen in Scenario 15.**

#### Strategy 2: Stable Centroid Offset (One Color Boundary)

This strategy handles the case where only one polygon (or "wall") is detected. It is designed for maximum stability and to solve the problem of jagged or looping paths (like in **Scenario 21** or **22**).

* **Step 1: Centroid Calculation**
    Instead of processing individual points on the boundary, the algorithm first calculates the single **geometric average (centroid)** of *all* visible cones of that color. This `avg_point` represents the "center of mass" of the detected boundary.

* **Step 2: Offset Vector Heuristic**
    The algorithm computes the vector from the car's position to this `avg_point`. This vector is used as a simple directional heuristic to determine which *side* to place the offset path.

* **Step 3: Single, Stable Waypoint Generation**
    Using the `car -> avg_point` vector, a perpendicular normal is calculated. The final waypoint is generated by offsetting the `avg_point` along this normal by half a track width. By creating only *one* stable waypoint based on the *entire* boundary, this method guarantees the path will move forward toward the cones.

---

### 3. Final Path Generation and Extension

1.  **Path Interpolation:** The list of waypoints (either from Strategy 1 or 2) is connected, starting from the `car_pos` (which is `(0,0)` in all scenarios). The path is densified with points every `0.4` meters to ensure a smooth, high-resolution route.
2.  **Forward-Facing Extension:** To ensure the car continues safely, the `final_heading` is calculated using the vector from the car's position to the **last waypoint**. This is used to set a stable *forward* direction for extending the path. The car's initial `yaw` is used as a fallback if no waypoints are found. The path is then extended for `16` meters (`40 * 0.4`) along this heading.

---

### 4. Key Assumptions and Limitations

This algorithm is built on several key assumptions, which define its scope and limitations:

* **Ideal Vehicle Model (Kinematics Ignored):** The algorithm's primary assumption is that the car is an ideal point that can follow a path perfectly. The path is generated as a series of `(x, y)` coordinates, and the algorithm **assumes the car can instantaneously change its direction** to follow this path. The car's current `yaw` (heading) and physical constraints like turning radius are **not** considered during path generation.

* **Left-to-Right Track Assumption:** The core logic of this solution relies on sorting all cones and waypoints by their **`x`-coordinate**. This makes it very robust for all scenarios provided, but introduces a new limitation:
    * **Limitation:** The algorithm assumes the track always proceeds from **left-to-right (increasing `x` values)**. It would likely fail on a track that is perfectly vertical (all cones share one `x` value) or on a track that features a U-turn and moves from right-to-left.