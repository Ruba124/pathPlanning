

Here is the updated documentation. I've added a new, clear section for your assumptions, including the one about the car's movement.

---

## Path Planning Solution Documentation

### 1. Algorithm Overview

This path planning algorithm generates a smooth, drivable path based on the core idea of **dynamic boundary generation**. The fundamental concept is to treat the blue and yellow cones as points defining two "polygons" or boundaries—a left (blue) boundary and a right (yellow) boundary.

The algorithm's design aims to generate a path that always stays between these two boundaries. It dynamically switches between two key strategies to achieve this:

1.  **Centerline Generation (Two-Sided Path):** Used when *both* blue and yellow boundaries (polygons) are detected. It calculates a centerline by pairing points from each boundary and intelligently extrapolating a path.
2.  **Stable Offset Generation (One-Sided Path):** Used when *only one* boundary (e.g., just the blue polygon) is detected. It calculates a single, stable offset path that runs parallel to this boundary.

---

### 2. Core Strategies Explained

#### Strategy 1: Centerline Generation (Blue and Yellow Boundaries)

This strategy implements the "two-polygon" concept when both are visible. It is built on the idea of **Geometric Pairing and Extrapolation**.

* **Step 1: Sorting by Proximity**
    To establish a logical pairing order between the two boundaries, both the blue and yellow cone lists are independently sorted based on their Euclidean distance from the car's position (`car_pos`). This uses the car's position only as a *sorting origin* to pair the "closest" points of each polygon first.

* **Step 2: Real Pair Midpoint Generation**
    The algorithm iterates through the sorted lists and creates "real pairs" for as long as both boundaries have points. The midpoint of each pair—e.g., `(blue[0], yellow[0])`—is calculated and added as a waypoint.

* **Step 3: Boundary Extrapolation (The "Virtual Cone" Concept)**
    This is the core innovation for handling uneven boundaries (like **Scenario 7**). The algorithm stores the vector from the *last real pair* (e.g., `y_cone.pos - b_cone.pos`). This `last_offset_vector` is stored as the "assumed track width and orientation," based purely on the detected boundary geometry.

* **Step 4: Virtual Waypoint Generation**
    For any remaining *unpaired* points on a boundary (e.g., an extra blue cone), the algorithm projects a "virtual" partner based on the stored track geometry.
    * If a `blue_cone` is unpaired, a `virtual_yellow` is created at `blue_cone.pos + last_offset_vector`.
    * If a `yellow_cone` is unpaired, a `virtual_blue` is created at `yellow_cone.pos - last_offset_vector`.
    The midpoint between the real point and its virtual partner is then added to the waypoint list. This allows the path to continue smoothly along the centerline.

#### Strategy 2: Stable Centroid Offset (One Color Boundary)

This strategy handles the case where only one polygon (or "wall") is detected. It is designed for maximum stability and to solve the problem of jagged or looping paths (like in **Scenario 21** or **22**).

* **Step 1: Centroid Calculation**
    Instead of processing individual points on the boundary, the algorithm first calculates the single **geometric average (centroid)** of *all* visible cones of that color. This `avg_point` represents the "center of mass" of the detected boundary.

* **Step 2: Offset Vector Heuristic**
    The algorithm computes the vector from the car's position to this `avg_point`. This vector is used as a simple directional heuristic to determine which *side* to place the offset path.

* **Step 3: Single, Stable Waypoint Generation**
    Using the `car -> avg_point` vector, a perpendicular normal is calculated. The final waypoint is generated by offsetting the `avg_point` along this normal by half a track width. By creating only *one* stable waypoint based on the *entire* boundary, this method guarantees the path will move forward toward the cones and will not have any zig-zags or loops.

---

### 3. Final Path Generation and Extension

1.  **Path Interpolation:** The list of waypoints (either from Strategy 1 or 2) is connected, starting from the `car_pos`. The path is densified with points every `0.4` meters to ensure a smooth, high-resolution route.
2.  **Forward-Facing Extension:** To ensure the car continues safely, the `final_heading` is calculated using the vector from the car's position to the **last waypoint**. This is used to set a stable *forward* direction for extending the path, preventing it from curling backward. The car's initial `yaw` is used as a fallback if no waypoints are found. The path is then extended for `16` meters (`40 * 0.4`) along this heading.

---

### 4. Key Assumptions and Limitations

This algorithm is built on several key assumptions, which define its scope and limitations:

* **Ideal Vehicle Model (Kinematics Ignored):** The algorithm's primary assumption is that the car is an ideal point that can follow a path perfectly. The path is generated as a series of `(x, y)` coordinates, and the algorithm **assumes the car can instantaneously change its direction** to follow this path. The car's current `yaw` (heading) and physical constraints like turning radius or acceleration are **not** considered during path generation.

* **Known Limitation (Scenario 15):** The **Proximity-Based Sorting** in Strategy 1 is a *pairing* heuristic, not a *travel-order* heuristic. In complex curves, this can lead to an incorrect waypoint order.
    * **Failure Analysis (Scenario 15):**
        1.  **Cones:** Blue `(2,5)`, `(3,4)`. Yellow `(3,2)`.
        2.  **Sorting (from `car_pos = (0,0)`):**
            * `blue_cones` = `[Cone(3,4), Cone(2,5)]`
            * `yellow_cones` = `[Cone(3,2)]`
        3.  **Pairing:** The closest pair is `Cone(3,4)` and `Cone(3,2)`. This creates the first waypoint at **`(3.0, 3.0)`**. The `last_offset_vector` is set to `(0, -2)`.
        4.  **Extrapolation:** The unpaired cone `Cone(2,5)` is processed. A `virtual_yellow` is created at `(2, 5-2) = (2, 3)`.
        5.  **Second Waypoint:** The midpoint between `(2,5)` and `(2,3)` is calculated as **`(2.0, 4.0)`**.
        6.  **Result:** The final, ordered waypoint list is `[(3.0, 3.0), (2.0, 4.0)]`. The path from the car `(0,0)` correctly goes to `(3.0, 3.0)` but then **turns backward** to `(2.0, 4.0)`, causing the car to fail the track.